// Alloy Analyzer 4 -- Copyright (c) 2006-2008, Felix Chang
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files
// (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify,
// merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
// OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

package de.uka.ilkd.alloy2key.alloy4.parser;

import edu.mit.csail.sdg.alloy4.Err;
import edu.mit.csail.sdg.alloy4.ErrorSyntax;
import edu.mit.csail.sdg.alloy4.Pos;
import de.uka.ilkd.alloy2key.alloy4.ast.ExprConstant;
import de.uka.ilkd.alloy2key.alloy4.ast.ExprVar;
import java.util.List;
import java_cup_11a.runtime.*;

/** Autogenerated by JFlex 1.4.1 */

%%

// There are 3 sets of "special tokens" that the lexer will not output.
// But the Parser expects them.
// So a special Filter class is written that sits between Lexer and Parser.
// The Filter class observes the stream of tokens, and intelligently
// merges or changes some primitive tokens into special tokens.
// For more details, refer to the main documentation.
//
// But, very briefly, here are the 3 groups:
//
// (1) The lexer will generate only ALL, NO, LONE, ONE, SUM, SOME.
// It will not output ALL2, NO2, LONE2, ONE2, SUM2, SOME2.
// (The Filter class will change some ONE into ONE2, etc)
//
// (2) The lexer won't output NOTEQUALS, NOTIN, NOTLT, NOTLTE, NOTGT, NOTGTE.
// Instead it outputs them as separate tokens (eg. "NOT" "EQUALS").
// (The Filter class is used to merge them into a single "NOTEQUALS" token)
//
// (3) The lexer willn't output the 15 special arrows (eg. ONE_ARROW_ONE)
// Instead it outputs them as separate tokens (eg. "ONE", "ARROW", "ONE")
// (The Filter class is used to merge them into a single "ONE_ARROW_ONE" token)

%class Lexer // The ordering of these directives is important
%cupsym Sym
%cup
%eofval{
  return new Symbol(Sym.EOF, alloy_here(" "), alloy_here(" "));
%eofval}
%public
%final
%unicode
%line
%column
%pack

%{
 public String alloy_filename="";
 public int alloy_lineoffset=0; // If not zero, it is added to the current LINE NUMBER
 public List<Object> alloy_seenDollar;
 public CompModule alloy_module;
 private final Pos alloy_here(String txt) {
    return new Pos(alloy_filename,yycolumn+1,yyline+1+alloy_lineoffset,yycolumn+txt.length(),yyline+1);
 }
 private final Symbol alloy_sym(String txt, int type) {
    Pos p = alloy_here(txt); return new Symbol(type, p, p);
 }
 private final Symbol alloy_string(String txt) throws Err {
    Pos p = alloy_here(txt);
    throw new ErrorSyntax(p, "String literal is not currently supported.");
 }
 private final Symbol alloy_id(String txt) throws Err {
    Pos p=alloy_here(txt);
    if (alloy_seenDollar.size()==0 && txt.indexOf('$')>=0) alloy_seenDollar.add(null);
    return new Symbol(Sym.ID, p, ExprVar.make(p,txt));
 }
 private final Symbol alloy_num(String txt) throws Err {
    Pos p=alloy_here(txt);
    int n=0;
    try {
       n=Integer.parseInt(txt);
    } catch(NumberFormatException ex) {
       throw new ErrorSyntax(p, "The number "+txt+" is too large to be stored in a Java integer");
    }
    return new Symbol(Sym.NUMBER, p, ExprConstant.Op.NUMBER.make(p, n));
 }
%}

%%

"!"                   { return alloy_sym(yytext(), Sym.NOT         );}
"#"                   { return alloy_sym(yytext(), Sym.HASH        );}
"&&"                  { return alloy_sym(yytext(), Sym.AND         );}
"&"                   { return alloy_sym(yytext(), Sym.AMPERSAND   );}
"("                   { return alloy_sym(yytext(), Sym.LPAREN      );}
")"                   { return alloy_sym(yytext(), Sym.RPAREN      );}
"*"                   { return alloy_sym(yytext(), Sym.STAR        );}
"++"                  { return alloy_sym(yytext(), Sym.PLUSPLUS    );}
"+"                   { return alloy_sym(yytext(), Sym.PLUS        );}
","                   { return alloy_sym(yytext(), Sym.COMMA       );}
"->"                  { return alloy_sym(yytext(), Sym.ARROW       );}
"-"                   { return alloy_sym(yytext(), Sym.MINUS       );}
"."                   { return alloy_sym(yytext(), Sym.DOT         );}
"/"                   { return alloy_sym(yytext(), Sym.SLASH       );}
"::"                  { return alloy_sym(yytext(), Sym.DOT         );}
":>"                  { return alloy_sym(yytext(), Sym.RANGE       );}
":"                   { return alloy_sym(yytext(), Sym.COLON       );}
"<=>"                 { return alloy_sym(yytext(), Sym.IFF         );}
"<="                  { return alloy_sym(yytext(), Sym.LTE         );}
"<:"                  { return alloy_sym(yytext(), Sym.DOMAIN      );}
"<<"                  { return alloy_sym(yytext(), Sym.SHL         );}
"<"                   { return alloy_sym(yytext(), Sym.LT          );}
"=<"                  { return alloy_sym(yytext(), Sym.LTE         );}
"=="                  { return alloy_sym(yytext(), Sym.EQUALS      );}
"=>"                  { return alloy_sym(yytext(), Sym.IMPLIES     );}
"="                   { return alloy_sym(yytext(), Sym.EQUALS      );}
">>>"                 { return alloy_sym(yytext(), Sym.SHR         );}
">>"                  { return alloy_sym(yytext(), Sym.SHA         );}
">="                  { return alloy_sym(yytext(), Sym.GTE         );}
">"                   { return alloy_sym(yytext(), Sym.GT          );}
"@"                   { return alloy_sym(yytext(), Sym.AT          );}
"["                   { return alloy_sym(yytext(), Sym.LBRACKET    );}
"]"                   { return alloy_sym(yytext(), Sym.RBRACKET    );}
"^"                   { return alloy_sym(yytext(), Sym.CARET       );}
"{"                   { return alloy_sym(yytext(), Sym.LBRACE      );}
"||"                  { return alloy_sym(yytext(), Sym.OR          );}
"|"                   { return alloy_sym(yytext(), Sym.BAR         );}
"}"                   { return alloy_sym(yytext(), Sym.RBRACE      );}
"~"                   { return alloy_sym(yytext(), Sym.TILDE       );}
"abstract"            { return alloy_sym(yytext(), Sym.ABSTRACT    );}
"all"                 { return alloy_sym(yytext(), Sym.ALL         );}
"and"                 { return alloy_sym(yytext(), Sym.AND         );}
"assert"              { return alloy_sym(yytext(), Sym.ASSERT      );}
"as"                  { return alloy_sym(yytext(), Sym.AS          );}
"but"                 { return alloy_sym(yytext(), Sym.BUT         );}
"check"               { return alloy_sym(yytext(), Sym.CHECK       );}
"disjoint"            { return alloy_sym(yytext(), Sym.DISJ        );}
"disj"                { return alloy_sym(yytext(), Sym.DISJ        );}
"else"                { return alloy_sym(yytext(), Sym.ELSE        );}
"enum"                { return alloy_sym(yytext(), Sym.ENUM        );}
"exactly"             { return alloy_sym(yytext(), Sym.EXACTLY     );}
"exhaustive"          { return alloy_sym(yytext(), Sym.EXH         );}
"exh"                 { return alloy_sym(yytext(), Sym.EXH         );}
"expect"              { return alloy_sym(yytext(), Sym.EXPECT      );}
"extends"             { return alloy_sym(yytext(), Sym.EXTENDS     );}
"fact"                { return alloy_sym(yytext(), Sym.FACT        );}
"for"                 { return alloy_sym(yytext(), Sym.FOR         );}
"fun"                 { return alloy_sym(yytext(), Sym.FUN         );}
"iden"                { return alloy_sym(yytext(), Sym.IDEN        );}
"iff"                 { return alloy_sym(yytext(), Sym.IFF         );}
"implies"             { return alloy_sym(yytext(), Sym.IMPLIES     );}
"Int"                 { return alloy_sym(yytext(), Sym.SIGINT      );}
"int"                 { return alloy_sym(yytext(), Sym.INT         );}
"in"                  { return alloy_sym(yytext(), Sym.IN          );}
"let"                 { return alloy_sym(yytext(), Sym.LET         );}
"lone"                { return alloy_sym(yytext(), Sym.LONE        );}
"module"              { return alloy_sym(yytext(), Sym.MODULE      );}
"none"                { return alloy_sym(yytext(), Sym.NONE        );}
"not"                 { return alloy_sym(yytext(), Sym.NOT         );}
"no"                  { return alloy_sym(yytext(), Sym.NO          );}
"one"                 { return alloy_sym(yytext(), Sym.ONE         );}
"open"                { return alloy_sym(yytext(), Sym.OPEN        );}
"or"                  { return alloy_sym(yytext(), Sym.OR          );}
"partition"           { return alloy_sym(yytext(), Sym.PART        );}
"part"                { return alloy_sym(yytext(), Sym.PART        );}
"pred"                { return alloy_sym(yytext(), Sym.PRED        );}
"private"             { return alloy_sym(yytext(), Sym.PRIVATE     );}
"run"                 { return alloy_sym(yytext(), Sym.RUN         );}
"seq"                 { return alloy_sym(yytext(), Sym.SEQ         );}
"set"                 { return alloy_sym(yytext(), Sym.SET         );}
"sig"                 { return alloy_sym(yytext(), Sym.SIG         );}
"some"                { return alloy_sym(yytext(), Sym.SOME        );}
"String"              { return alloy_sym(yytext(), Sym.STRING      );}
"sum"                 { return alloy_sym(yytext(), Sym.SUM         );}
"this"                { return alloy_sym(yytext(), Sym.THIS        );}
"univ"                { return alloy_sym(yytext(), Sym.UNIV        );}

[\"] ([^\\\"] | ("\\" .))* [\"] [\$0-9a-zA-Z_\'\"] [\$0-9a-zA-Z_\'\"]* { throw new ErrorSyntax(alloy_here(yytext()),"String literal cannot be followed by a legal identifier character."); }
[\"] ([^\\\"] | ("\\" .))* [\"]                                        { return alloy_string(yytext()); }
[\"] ([^\\\"] | ("\\" .))*                                             { throw new ErrorSyntax(alloy_here(yytext()),"String literal is missing its closing \" character"); }
[0-9][0-9]*[\$a-zA-Z_\'\"][\$0-9a-zA-Z_\'\"]*                          { throw new ErrorSyntax(alloy_here(yytext()),"Name cannot start with a number."); }
[0-9][0-9]*                                                            { return alloy_num (yytext()); }
[\$a-zA-Z][\$0-9a-zA-Z_\'\"]*                                          { return alloy_id  (yytext()); }

"/**" ~"*/"                  { }

"/*" ~"*/"                   { }

("//"|"--") [^\r\n]* [\r\n]  { }

("//"|"--") [^\r\n]*         { } // This rule is shorter than the previous rule,
                                 // so it will only apply if the final line of a file is missing the \n or \r character.

[ \t\f\r\n]                  { }

. { throw new ErrorSyntax(alloy_here(" "), "Syntax error at the "+yytext()+" character."); }
