PS D:\Entwicklung\workspace\alloy2relsmt\smtexamples> z3 .\transcloslemmaproof2.smt2
WARNING: pulled nested quantifier to be able to find an useable pattern (quantifier id: k!45)
sat
(model
  ;; universe for Atom:
  ;;   Atom!val!0 Atom!val!1 Atom!val!2 Atom!val!4 Atom!val!3
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun Atom!val!0 () Atom)
  (declare-fun Atom!val!1 () Atom)
  (declare-fun Atom!val!2 () Atom)
  (declare-fun Atom!val!4 () Atom)
  (declare-fun Atom!val!3 () Atom)
  ;; cardinality constraint:
  (forall ((x Atom))
          (or (= x Atom!val!0)
              (= x Atom!val!1)
              (= x Atom!val!2)
              (= x Atom!val!4)
              (= x Atom!val!3)))
  ;; -----------
  ;; universe for Rel2:
  ;;   Rel2!val!0 Rel2!val!1 Rel2!val!2
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun Rel2!val!0 () Rel2)
  (declare-fun Rel2!val!1 () Rel2)
  (declare-fun Rel2!val!2 () Rel2)
  ;; cardinality constraint:
  (forall ((x Rel2)) (or (= x Rel2!val!0) (= x Rel2!val!1) (= x Rel2!val!2)))
  ;; -----------
  (define-fun r!5 () Rel2
    Rel2!val!0)
  (define-fun a2!6 () Atom
    Atom!val!1)
  (define-fun a1!7 () Atom
    Atom!val!0)
  (define-fun a1!4 ((x!1 Rel2)) Atom
    Atom!val!2)
  (define-fun a3!2 ((x!1 Rel2)) Atom
    Atom!val!4)
  (define-fun k!84 ((x!1 Atom)) Atom
    (ite (= x!1 Atom!val!4) Atom!val!4
    (ite (= x!1 Atom!val!1) Atom!val!1
    (ite (= x!1 Atom!val!3) Atom!val!3
    (ite (= x!1 Atom!val!0) Atom!val!0
      Atom!val!2)))))
  (define-fun a2!3 ((x!1 Rel2)) Atom
    Atom!val!3)
  (define-fun a0!1 ((x!1 Rel2) (x!2 Rel2)) Atom
    Atom!val!0)
  (define-fun in_2!87 ((x!1 Atom) (x!2 Atom) (x!3 Rel2)) Bool
    (ite (and (= x!1 Atom!val!0) (= x!2 Atom!val!1) (= x!3 Rel2!val!1)) true
    (ite (and (= x!1 Atom!val!2) (= x!2 Atom!val!3) (= x!3 Rel2!val!0)) true
    (ite (and (= x!1 Atom!val!3) (= x!2 Atom!val!4) (= x!3 Rel2!val!0)) true
    (ite (and (= x!1 Atom!val!3) (= x!2 Atom!val!4) (= x!3 Rel2!val!1)) true
    (ite (and (= x!1 Atom!val!2) (= x!2 Atom!val!3) (= x!3 Rel2!val!1)) true
    (ite (and (= x!1 Atom!val!0) (= x!2 Atom!val!1) (= x!3 Rel2!val!2)) true
    (ite (and (= x!1 Atom!val!2) (= x!2 Atom!val!3) (= x!3 Rel2!val!2)) true
    (ite (and (= x!1 Atom!val!3) (= x!2 Atom!val!4) (= x!3 Rel2!val!2)) true
    (ite (and (= x!1 Atom!val!2) (= x!2 Atom!val!4) (= x!3 Rel2!val!1)) true
    (ite (and (= x!1 Atom!val!2) (= x!2 Atom!val!4) (= x!3 Rel2!val!2)) true
      false)))))))))))
  (define-fun k!85 ((x!1 Rel2)) Rel2
    (ite (= x!1 Rel2!val!2) Rel2!val!2
    (ite (= x!1 Rel2!val!1) Rel2!val!1
      Rel2!val!0)))
  (define-fun in_2 ((x!1 Atom) (x!2 Atom) (x!3 Rel2)) Bool
    (in_2!87 (k!84 x!1) (k!84 x!2) (k!85 x!3)))
  (define-fun subset_2 ((x!1 Rel2) (x!2 Rel2)) Bool
    (forall ((a0 Atom) (a1 Atom)) (or (not (in_2 a0 a1 x!1)) (in_2 a0 a1 x!2))))
  (define-fun trans ((x!1 Rel2)) Bool
    (forall ((a1 Atom) (a2 Atom) (a3 Atom))
      (or (not (and (in_2 a1 a2 x!1) (in_2 a2 a3 x!1))) (in_2 a1 a3 x!1))))
  (define-fun transClos!86 ((x!1 Rel2)) Rel2
    (ite (= x!1 Rel2!val!1) Rel2!val!2
      Rel2!val!1))
  (define-fun transClos ((x!1 Rel2)) Rel2
    (transClos!86 (k!85 x!1)))
  (define-fun a1!0 ((x!1 Rel2) (x!2 Rel2)) Atom
    Atom!val!0)
)
PS D:\Entwicklung\workspace\alloy2relsmt\smtexamples> z3 .\transcloslemmaproof1.smt2
WARNING: pulled nested quantifier to be able to find an useable pattern (quantifier id: k!45)
sat
(model
  ;; universe for Atom:
  ;;   Atom!val!0 Atom!val!1 Atom!val!2 Atom!val!4 Atom!val!3
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun Atom!val!0 () Atom)
  (declare-fun Atom!val!1 () Atom)
  (declare-fun Atom!val!2 () Atom)
  (declare-fun Atom!val!4 () Atom)
  (declare-fun Atom!val!3 () Atom)
  ;; cardinality constraint:
  (forall ((x Atom))
          (or (= x Atom!val!0)
              (= x Atom!val!1)
              (= x Atom!val!2)
              (= x Atom!val!4)
              (= x Atom!val!3)))
  ;; -----------
  ;; universe for Rel2:
  ;;   Rel2!val!0 Rel2!val!1
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun Rel2!val!0 () Rel2)
  (declare-fun Rel2!val!1 () Rel2)
  ;; cardinality constraint:
  (forall ((x Rel2)) (or (= x Rel2!val!0) (= x Rel2!val!1)))
  ;; -----------
  (define-fun r!5 () Rel2
    Rel2!val!0)
  (define-fun a2!6 () Atom
    Atom!val!1)
  (define-fun a1!7 () Atom
    Atom!val!0)
  (define-fun a1!4 ((x!1 Rel2)) Atom
    Atom!val!2)
  (define-fun a3!2 ((x!1 Rel2)) Atom
    Atom!val!4)
  (define-fun k!69 ((x!1 Rel2)) Rel2
    (ite (= x!1 Rel2!val!1) Rel2!val!1
      Rel2!val!0))
  (define-fun in_2!70 ((x!1 Atom) (x!2 Atom) (x!3 Rel2)) Bool
    (ite (and (= x!1 Atom!val!0) (= x!2 Atom!val!1) (= x!3 Rel2!val!1)) true
    (ite (and (= x!1 Atom!val!2) (= x!2 Atom!val!3) (= x!3 Rel2!val!0)) true
    (ite (and (= x!1 Atom!val!3) (= x!2 Atom!val!4) (= x!3 Rel2!val!0)) true
    (ite (and (= x!1 Atom!val!3) (= x!2 Atom!val!4) (= x!3 Rel2!val!1)) true
    (ite (and (= x!1 Atom!val!2) (= x!2 Atom!val!3) (= x!3 Rel2!val!1)) true
    (ite (and (= x!1 Atom!val!2) (= x!2 Atom!val!4) (= x!3 Rel2!val!1)) true
      false)))))))
  (define-fun k!68 ((x!1 Atom)) Atom
    (ite (= x!1 Atom!val!4) Atom!val!4
    (ite (= x!1 Atom!val!1) Atom!val!1
    (ite (= x!1 Atom!val!3) Atom!val!3
    (ite (= x!1 Atom!val!0) Atom!val!0
      Atom!val!2)))))
  (define-fun in_2 ((x!1 Atom) (x!2 Atom) (x!3 Rel2)) Bool
    (in_2!70 (k!68 x!1) (k!68 x!2) (k!69 x!3)))
  (define-fun subset_2 ((x!1 Rel2) (x!2 Rel2)) Bool
    (forall ((a0 Atom) (a1 Atom)) (or (not (in_2 a0 a1 x!1)) (in_2 a0 a1 x!2))))
  (define-fun trans ((x!1 Rel2)) Bool
    (forall ((a1 Atom) (a2 Atom) (a3 Atom))
      (or (not (and (in_2 a1 a2 x!1) (in_2 a2 a3 x!1))) (in_2 a1 a3 x!1))))
  (define-fun transClos ((x!1 Rel2)) Rel2
    Rel2!val!1)
  (define-fun a1!0 ((x!1 Rel2) (x!2 Rel2)) Atom
    Atom!val!0)
  (define-fun a2!3 ((x!1 Rel2)) Atom
    Atom!val!3)
  (define-fun a0!1 ((x!1 Rel2) (x!2 Rel2)) Atom
    Atom!val!0)
)
PS D:\Entwicklung\workspace\alloy2relsmt\smtexamples>